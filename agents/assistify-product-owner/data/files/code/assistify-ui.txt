# ai-assistant-manager

## exporter_test.py

### Summary

This code contains unit tests for functions from the `ai_assistant_manager.exporters.exporter` module. It uses `unittest.mock` to simulate and control dependencies:

1. **`test_does_data_exist`**: Mock tests the `does_data_exist` function to return `True` if a file path exists.
2. **`test_create_dir_data_exists`**: Checks that `create_dir` does not call `os.makedirs` if `does_data_exist` returns `True`.
3. **`test_create_dir_data_does_not_exist`**: Ensures `create_dir` does call `os.makedirs` if `does_data_exist` returns `False`.

Mocks and patches are used to simulate the behavior of file existence and directory creation.

```py
from unittest.mock import Mock, patch

from ai_assistant_manager.exporters.exporter import create_dir, does_data_exist


def test_does_data_exist():
    file_path = Mock(return_value="path/to/file")

    with patch("os.path.exists", return_value=True):
        result = does_data_exist(file_path)

    assert result


@patch("ai_assistant_manager.exporters.exporter.does_data_exist")
def test_create_dir_data_exists(mock_does_data_exist):
    mock_does_data_exist.return_value = True

    with patch("os.makedirs") as mock_makedirs:
        create_dir("dir/path", "file/path")

    mock_makedirs.assert_not_called()


@patch("ai_assistant_manager.exporters.exporter.does_data_exist")
def test_create_dir_data_does_not_exist(mock_does_data_exist):
    mock_does_data_exist.return_value = False

    with patch("os.makedirs") as mock_makedirs:
        create_dir("dir/path", "file/path")

    mock_makedirs.assert_called_once_with("dir/path", exist_ok=True)

```

## encoding.py

### Summary

The code defines a constant `UTF_8` with the value `"utf-8"`.

```py
UTF_8 = "utf-8"

```

## timer_test.py

### Summary

This code is a unit test for a `timer` decorator. The `test_timer_decorator` function tests whether the `timer` decorator logs a debug message when a decorated function (`dummy_function`) is called. It uses `unittest.mock.patch` to mock the logger and verifies that the logger's `debug` method was called exactly once with a message indicating the test function's completion time.

```py
from unittest.mock import patch

from ai_assistant_manager.timer.timer import timer


def test_timer_decorator():
    @timer("Test function")
    def dummy_function():
        pass

    with patch("ai_assistant_manager.timer.timer.logger") as mock_logger:
        dummy_function()

    mock_logger.debug.assert_called_once()
    assert "Test function: completed in" in mock_logger.debug.call_args[0][0]

```

## timer.py

### Summary

This code is a Python decorator named `timer` that measures and logs the execution time of any function it decorates, using the `loguru` logger for logging. The `timer` decorator accepts a custom message that is included in the log.

```py
import time
from functools import wraps

from loguru import logger


def timer(message: str):
    """
    Decorator to measure the execution time of a function and log it.

    :param message: The message to include in the log.
    :return: The decorator function.
    """

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            elapsed_time = round(end_time - start_time, 4)
            logger.debug(f"{message}: completed in {elapsed_time} seconds")
            return result

        return wrapper

    return decorator

```

## exporter.py

### Summary

This code defines two functions for managing file and directory existence:

1. **does_data_exist(file_path: str) -> bool**: Checks if a file exists at the given `file_path`.

2. **create_dir(dir_path: str, file_path: str)**: Creates a directory at `dir_path` only if the file at `file_path` doesn't exist, logging the creation action using `loguru`.

```py
import os

from loguru import logger


def does_data_exist(file_path: str) -> bool:
    """
    Check if the data file exists at the given file path.

    This function is used to determine whether a specific data file is already present,
    which helps in deciding whether to create a new directory or not.

    :param file_path: The path to the data file.
    :return: True if the file exists, False otherwise.
    """
    return os.path.exists(file_path)


def create_dir(dir_path: str, file_path: str):
    """
    Create a directory if the data file does not exist.

    This function ensures that the directory structure is in place before any data files are created.
    It prevents redundant directory creation if the data file already exists.

    :param dir_path: The path to the directory to create.
    :param file_path: The path to the data file to check.
    """
    if not does_data_exist(file_path):
        logger.info(f"Creating data dir path: {dir_path}")
        os.makedirs(dir_path, exist_ok=True)

```

## pyproject.toml

### Summary

This configuration file is for a Python project named "ai-assistant-manager." It uses the Hatchling build system to manage its build process. Essential project metadata includes a description, author information, and licensing. Dependencies for the project include `loguru`, `openai`, `python-dotenv`, and `twine`. The project is compatible with Python version 3.11 and higher.

Hatch configurations are set for building both source distributions (sdist) and wheel distributions, specifying included packages and artifacts. Virtual environment settings include dependencies like `pyright`, `pytest`, and `pytest-cov`, as well as scripts for end-to-end testing, running tests, and publishing the package. It also includes configuration for the Ruff static analysis tool, prohibiting certain types of relative imports via `flake8-tidy-imports` settings. The source code is versioned based on the pattern defined in `setup.cfg` and the project's repository is hosted on GitHub.

```toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "ai-assistant-manager"
dynamic = ["version"]
description = "This repository provides tools and services to manage OpenAI Assistants, including creating, listing, and deleting assistants, as well as handling vector stores and retrieval files."
license = { file = "LICENSE" }
readme = "README.md"
authors = [{ name = "Justin Beall", email = "jus.beall@gmail.com" }]
requires-python = ">=3.11"
dependencies = ["loguru", "openai", "python-dotenv", "twine"]
keywords = [
    "openai",
    "assistant",
    "management",
    "AI",
    "vector store",
    "machine learning",
    "natural language processing",
    "NLP",
    "chatbot",
    "automation",
    "python",
    "API",
    "deep learning",
    "artificial intelligence",
    "data science",
]

classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Topic :: Software Development :: Libraries :: Python Modules",
]

[project.urls]
repository = "https://github.com/DEV3L/open-ai-assistant"

[tool.hatch.version]
path = "setup.cfg"
pattern = "version = (?P<version>\\S+)"

[tool.hatch.build.targets.sdist]
include = ["/ai_assistant_manager"]
artifact = { name = "ai-assistant-manager" }

[tool.hatch.build.targets.wheel]
packages = ["ai_assistant_manager"]
artifact = { name = "ai-assistant-manager" }

[tool.hatch.envs.default]
type = "virtual"
path = ".venv"
dependencies = ["pyright", "pytest", "pytest-cov"]

[tool.hatch.envs.default.scripts]
e2e = "python run_end_to_end.py"
test = "pytest --cache-clear --cov --cov-report lcov --cov-report term"
publish = "rm -rf bin && rm -rf dist && hatch build && twine upload dist/*"

[tool.hatch.envs.hatch-static-analysis]
config-path = "ruff_defaults.toml"

[tool.ruff]
extend = "ruff_defaults.toml"

[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "parents"

```

## files_exporter_test.py

### Summary

The provided code is a set of unit tests for the `FilesExporter` class from the `ai_assistant_manager` module. Here's a summary of the code:

1. **Imports Libraries and Modules:**

   - Uses `unittest.mock` for mocking.
   - Uses `pytest` for testing framework.
   - Imports constants and the `FilesExporter` class from the module.

2. **Fixture Definition:**

   - Defines a `pytest` fixture `build_exporter` to create an instance of `FilesExporter` with specific parameters (`FILE_NAME` and `DATA_DIRECTORY`).

3. **Test Functions:**

   - **`test_export_data_exists`:**

     - Tests the `export` method when data already exists.
     - Mocks `does_data_exist` to return `True`.
     - Asserts `create_dir` is not called.

   - **`test_export_data_does_not_exist`:**

     - Tests the `export` method when data does not exist.
     - Mocks `does_data_exist` to return `False`.
     - Mocks `write_data`.
     - Asserts `create_dir` and `write_data` are called once.

   - **`test_write_data`:**

     - Tests the `write_data` method.
     - Mocks `get_file_path` to return a specific path.
     - Asserts `shutil.copy` is called with correct source and destination paths.

   - **`test_get_dir_path`:**

     - Tests `get_dir_path` method.
     - Asserts the returned directory path is correct.

   - **`test_get_file_path`:**
     - Tests `get_file_path` method.
     - Asserts the returned file path is correct.

```py
from unittest.mock import Mock, patch

import pytest

from ai_assistant_manager.env_variables import BIN_DIR, DATA_DIR, DATA_FILE_PREFIX
from ai_assistant_manager.exporters.files.files_exporter import FilesExporter

FILE_NAME = "test_file.txt"
DATA_DIRECTORY = "test_dir"


@pytest.fixture(name="exporter")
def build_exporter():
    return FilesExporter(FILE_NAME, directory=DATA_DIRECTORY)


@patch("ai_assistant_manager.exporters.files.files_exporter.create_dir")
@patch("ai_assistant_manager.exporters.files.files_exporter.does_data_exist")
def test_export_data_exists(mock_does_data_exist, mock_create_dir, exporter):
    mock_does_data_exist.return_value = True

    exporter.export()

    mock_create_dir.assert_not_called()


@patch("ai_assistant_manager.exporters.files.files_exporter.create_dir")
@patch("ai_assistant_manager.exporters.files.files_exporter.does_data_exist")
def test_export_data_does_not_exist(mock_does_data_exist, mock_create_dir, exporter):
    mock_does_data_exist.return_value = False

    exporter.write_data = Mock()

    exporter.export()

    mock_create_dir.assert_called_once()
    exporter.write_data.assert_called_once()


@patch("ai_assistant_manager.exporters.files.files_exporter.shutil")
def test_write_data(mock_shutil, exporter):
    exporter.get_file_path = Mock(return_value="path/to/file")

    exporter.write_data()

    mock_shutil.copy.assert_called_once_with(f"{DATA_DIR}/{DATA_DIRECTORY}/{FILE_NAME}", "path/to/file")


def test_get_dir_path(exporter):
    result = exporter.get_dir_path()

    assert result == f"{BIN_DIR}/{DATA_DIRECTORY}"


def test_get_file_path(exporter):
    result = exporter.get_file_path()

    assert result == f"{BIN_DIR}/{DATA_DIRECTORY}/{DATA_FILE_PREFIX}_{FILE_NAME}"

```

## assistant_service_test.py

### Summary

This code is a unit test suite for the `AssistantService` class, part of `ai_assistant_manager`. It leverages the `unittest` module from Python to mock external dependencies and test the functionality of various methods in `AssistantService`. Here's a brief summary of the tests:

1. **Setup (`setUp` method)**:

   - Initializes the mock client and the `AssistantService` instance with a given prompt.

2. **Tests for `get_assistant_id` method**:

   - **`test_get_assistant_id_exists`**: Verifies that the method returns the correct assistant ID if the assistant already exists.
   - **`test_get_assistant_id_not_exists`**: Verifies that the method creates a new assistant if it doesn't exist and returns the new ID.

3. **Tests for `get_vector_store_ids` method**:

   - **`test_get_vector_store_ids_exists`**: Ensures correct vector store IDs are returned if they exist.

4. **Tests for `create_vector_stores` method**:

   - **`test_create_vector_stores`**: Checks vector store creation with proper file IDs.
   - **`test_create_vector_stores_with_failed_files`**: Ensures proper handling and retry for failed file creation.

5. **Test for `_validate_vector_stores` method**:

   - **`test_validate_vector_stores`**: Confirms that vector stores validate correctly when all files are completed.

6. **Tests for `get_retrieval_file_ids` method**:

   - **`test_get_retrieval_file_ids_exists`**: Verifies the correct retrieval file IDs if they exist.

7. **Test for `create_retrieval_files` method**:

   - **`test_create_retrieval_files`**: Assures new retrieval files are created and IDs are returned.

8. **Tests for `delete_assistant` method**:
   - **`test_delete_assistant_with_existing_assistant_and_files`**: Checks the deletion of an assistant along with its associated files.
   - **`test_delete_assistant_with_no_existing_assistant_and_files`**: Confirms no action is taken if there are no existing assistants or files to delete.

```py
from unittest import TestCase, mock
from unittest.mock import MagicMock, mock_open, patch

from ai_assistant_manager.assistants.assistant_service import AssistantService
from ai_assistant_manager.env_variables import ASSISTANT_NAME, DATA_FILE_PREFIX


class TestAssistantService(TestCase):
    service: AssistantService
    prompt = "A helpful assistant"

    def setUp(self):
        self.mock_client = MagicMock()

        self.service = AssistantService(self.mock_client, self.prompt)

    def test_get_assistant_id_exists(self):
        mock_assistant = MagicMock(id="456")
        mock_assistant.name = ASSISTANT_NAME
        self.mock_client.assistants_list = MagicMock(
            return_value=[
                mock_assistant,
            ]
        )

        result = self.service.get_assistant_id()

        assert result == "456"
        self.mock_client.assistants_list.assert_called_once()
        self.mock_client.assistants_create.assert_not_called()

    def test_get_assistant_id_not_exists(self):
        self.mock_client.assistants_list = MagicMock(return_value=[])

        result = self.service.get_assistant_id()

        assert result == self.mock_client.assistants_create.return_value.id

    def test_get_vector_store_ids_exists(self):
        self.mock_client.vector_stores_list = MagicMock(
            return_value=[
                MagicMock(filename=f"{DATA_FILE_PREFIX} vector store", id="654"),
            ]
        )

        result = self.service.get_vector_store_ids()

        assert result == ["654"]
        self.mock_client.vector_stores_list.assert_called_once()
        self.mock_client.create_vector_stores.assert_not_called()

    def test_create_vector_stores(self):
        expected_vector_store_id = "vector_store_id"
        expected_file_ids = ["file1_id", "file2_id"]
        self.mock_client.vector_stores_create.return_value = expected_vector_store_id
        self.mock_client.vector_stores_files.return_value = [
            MagicMock(status="completed"),
        ]

        self.service.get_retrieval_file_ids = lambda: expected_file_ids

        vector_store_ids = self.service.create_vector_stores()

        assert vector_store_ids == [expected_vector_store_id]
        self.mock_client.vector_stores_create.assert_called_with(mock.ANY, expected_file_ids)
        self.mock_client.vector_stores_files.assert_called_with(expected_vector_store_id)

    def test_create_vector_stores_with_failed_files(self):
        expected_vector_store_id = "vector_store_id"
        expected_file_ids = ["file1_id", "file2_id"]
        self.mock_client.vector_stores_create.return_value = expected_vector_store_id
        self.mock_client.vector_stores_files.side_effect = [
            [MagicMock(status="failed", id="abc")],
            lambda: Exception("Failed to create vector store"),
            [MagicMock(status="completed", id="def")],
        ]
        self.mock_client.files_get.return_value = MagicMock(filename="file_name")
        self.service.get_retrieval_file_ids = lambda: expected_file_ids

        mock_os_walk = [("root", None, ["file_name"])]

        with patch("os.walk", return_value=mock_os_walk), patch("builtins.open", mock_open(read_data="data")):
            vector_store_ids = self.service.create_vector_stores()

        assert vector_store_ids == [expected_vector_store_id]
        self.mock_client.vector_stores_file_delete.assert_called_with(expected_vector_store_id, "abc")
        self.mock_client.vector_stores_create.assert_called_with(mock.ANY, expected_file_ids)
        self.mock_client.vector_stores_files.assert_called_with(expected_vector_store_id)

    def test_validate_vector_stores(self):
        expected_vector_store_id = "vector_store_id"

        self.mock_client.vector_stores_files.return_value = [
            MagicMock(status="completed"),
        ]

        vector_store_id = self.service._validate_vector_stores(expected_vector_store_id)

        assert vector_store_id == expected_vector_store_id

    def test_get_retrieval_file_ids_exists(self):
        self.mock_client.files_list = MagicMock(
            return_value=[
                MagicMock(filename=f"{DATA_FILE_PREFIX} blogs.json", id="456"),
            ]
        )

        result = self.service.get_retrieval_file_ids()

        assert result == ["456"]
        self.mock_client.files_list.assert_called_once()
        self.mock_client.files_create.assert_not_called()

    def test_create_retrieval_files(self):
        self.mock_client.files_create.return_value.id = "file_id"

        mock_os_walk = [("root", None, ["file1", "file2"])]
        expected_file_ids = ["file_id", "file_id"]

        with patch("os.walk", return_value=mock_os_walk), patch("builtins.open", mock_open(read_data="data")):
            actual_file_ids = self.service.create_retrieval_files()

        assert actual_file_ids == expected_file_ids
        self.mock_client.files_create.assert_called_with(mock.ANY, "assistants")

    # pylint: disable=protected-access
    def test_delete_assistant_with_existing_assistant_and_files(self):
        self.service._find_existing_assistant = MagicMock(return_value="assistant_id")
        self.service._find_existing_vector_stores = MagicMock(return_value=["vs1_id", "vs2_id"])
        self.service._find_existing_retrieval_files = MagicMock(return_value=["file1_id", "file2_id"])

        self.service.delete_assistant()

        self.service._find_existing_assistant.assert_called_once()
        self.service._find_existing_vector_stores.assert_called_once()
        self.service._find_existing_retrieval_files.assert_called_once()
        self.mock_client.assistants_delete.assert_called_once_with("assistant_id")
        self.mock_client.vector_stores_delete.assert_any_call("vs1_id")
        self.mock_client.vector_stores_delete.assert_any_call("vs2_id")
        self.mock_client.files_delete.assert_any_call("file1_id")
        self.mock_client.files_delete.assert_any_call("file2_id")

    def test_delete_assistant_with_no_existing_assistant_and_files(self):
        self.service._find_existing_assistant = MagicMock(return_value=None)
        self.service._find_existing_retrieval_files = MagicMock(return_value=None)

        self.service.delete_assistant()

        self.service._find_existing_assistant.assert_called_once()
        self.service._find_existing_retrieval_files.assert_called_once()
        self.mock_client.assistants_delete.assert_not_called()
        self.mock_client.files_delete.assert_not_called()

    # pylint: enable=protected-access

```

## continuous-integration.yml

### Summary

This GitHub Actions workflow, named "Continuous Integration," triggers on any branch push. It sets up a job named "Tests" which runs on the latest Ubuntu version. The job includes steps to checkout the repository, set up Python 3.x, install dependencies using Hatch, and execute unit tests.

```yml
name: Continuous Integration

on:
  push:
    branches: ["**"]

jobs:
  tests:
    name: "Tests"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.x"
      - name: Install dependencies
        run: |
          python -m pip install hatch
          hatch env create
      - name: Unit tests
        run: |
          hatch run test
```

## openai_api_test.py

### Summary

The code contains unit tests for the `OpenAIClient` class. It primarily uses the `unittest` framework and mocks external dependencies using `unittest.mock`. Here's a concise summary:

1. **Test Setup:**

   - `test_build_openai_client`: Verifies that the `build_openai_client` function returns an instance of `OpenAI`.
   - `TestOpenAIClient` class: Establishes the `OpenAIClient` and mocks its dependencies for various tests.

2. **Tests:**

   - **Threads Operations**:
     - `test_threads_create`: Ensures `threads_create` method calls the correct API.
   - **Messages Operations**:
     - `test_messages_list`, `test_messages_create`: Tests listing and creating messages in a thread.
   - **Runs Operations**:
     - `test_runs_create`, `test_runs_create_with_tool_choice`, `test_runs_retrieve`: Validates the creation and retrieval of runs.
   - **Assistants Operations**:
     - `test_assistants_list`, `test_assistants_create`, `test_assistants_delete`: Tests listing, creating, and deleting assistants.
   - **Files Operations**:
     - `test_files_list`, `test_files_get`, `test_files_create`, `test_files_delete`: Checks listing, retrieving, creating, and deleting files.
   - **Vector Stores Operations**:
     - `test_vector_stores_list`, `test_vector_stores_retrieve`, `test_vector_stores_create`, `test_vector_stores_create_with_failed_files`, `test_vector_stores_update`, `test_vector_stores_delete`, `test_vector_stores_file_delete`, `test_vector_stores_files`: Tests various vector store functionalities including creation, retrieval, and file management within vector stores.

3. **Utilities:**
   - `patch` decorator: Mocks dependencies such as `time` and `logger` for specific tests to ensure the code relies on tested logic and not actual service responses.

In essence, the suite comprehensively tests the `OpenAIClient` for interactions with the OpenAI API, ensuring each method functions correctly through mocked responses.

```py
from unittest import TestCase
from unittest.mock import MagicMock, patch

from ai_assistant_manager.clients.openai_api import OpenAIClient, build_openai_client


@patch("ai_assistant_manager.clients.openai_api.OpenAI")
def test_build_openai_client(mock_openai):
    client = build_openai_client()

    assert client is mock_openai.return_value

    mock_openai.assert_called_once_with(timeout=90)


class TestOpenAIClient(TestCase):
    client: OpenAIClient

    mock_open_ai: MagicMock

    def setUp(self):
        self.mock_open_ai = MagicMock()

        self.client = OpenAIClient(self.mock_open_ai)

    def test_threads_create(self):
        self.client.threads_create()

        self.mock_open_ai.beta.threads.create.assert_called()

    def test_messages_list(self):
        thread_id = "thread_id"

        self.client.messages_list(thread_id)

        self.mock_open_ai.beta.threads.messages.list.assert_called_once_with(thread_id)

    def test_messages_create(self):
        thread_id = "thread_id"
        content = "Hello"
        role = "user"

        self.client.messages_create(thread_id, content, role)

        self.mock_open_ai.beta.threads.messages.create.assert_called_once_with(
            thread_id=thread_id, content=content, role=role
        )

    def test_runs_create(self):
        thread_id = "thread_id"
        assistant_id = "assistant_id"

        self.client.runs_create(assistant_id, thread_id, False)

        self.mock_open_ai.beta.threads.runs.create_and_poll.assert_called_once_with(
            thread_id=thread_id, assistant_id=assistant_id, tool_choice=None
        )

    def test_runs_create_with_tool_choice(self):
        thread_id = "thread_id"
        assistant_id = "assistant_id"

        self.client.runs_create(assistant_id, thread_id, True)

        self.mock_open_ai.beta.threads.runs.create_and_poll.assert_called_once_with(
            thread_id=thread_id, assistant_id=assistant_id, tool_choice={"type": "file_search"}
        )

    def test_runs_retrieve(self):
        run_id = "run_id"
        thread_id = "thread_id"

        self.client.runs_retrieve(run_id, thread_id)

        self.mock_open_ai.beta.threads.runs.retrieve.assert_called_once_with(run_id, thread_id=thread_id)

    def test_assistants_list(self):
        self.client.assistants_list()

        self.mock_open_ai.beta.assistants.list.assert_called_once()

    def test_assistants_create(self):
        name = "assistant_name"
        instructions = "instructions"
        tools = [{"tool_name": "tool"}]
        vector_store_ids = ["vector_store_id"]

        self.client.assistants_create(name, instructions, vector_store_ids, tools)

        self.mock_open_ai.beta.assistants.create.assert_called_once_with(
            name=name,
            instructions=instructions,
            model="gpt-4o",
            tool_resources={"file_search": {"vector_store_ids": vector_store_ids}},
            tools=tools,
        )

    def test_assistants_delete(self):
        assistant_id = "assistant_id"

        self.client.assistants_delete(assistant_id)

        self.mock_open_ai.beta.assistants.delete.assert_called_once_with(assistant_id)

    def test_files_list(self):
        files = self.client.files_list()

        self.mock_open_ai.files.list.assert_called_once()
        assert files == self.mock_open_ai.files.list.return_value

    def test_files_get(self):
        file_id = "file_id"

        file = self.client.files_get(file_id)

        self.mock_open_ai.files.retrieve.assert_called_once_with(file_id)
        assert file == self.mock_open_ai.files.retrieve.return_value

    def test_files_create(self):
        file = MagicMock()
        purpose = "assistants"

        self.client.files_create(file, purpose)

        self.mock_open_ai.files.create.assert_called_once_with(file=file, purpose=purpose)

    def test_files_delete(self):
        file_id = "file_id"

        self.client.files_delete(file_id)

        self.mock_open_ai.files.delete.assert_called_once_with(file_id)

    def test_vector_stores_list(self):
        vector_stores = self.client.vector_stores_list()

        self.mock_open_ai.beta.vector_stores.list.assert_called_once()
        assert vector_stores == self.mock_open_ai.beta.vector_stores.list.return_value

    def test_vector_stores_retrieve(self):
        vector_store_id = "vector_store_id"

        vector_store = self.client.vector_stores_retrieve(vector_store_id)

        self.mock_open_ai.beta.vector_stores.retrieve.assert_called_once_with(vector_store_id)
        assert vector_store == self.mock_open_ai.beta.vector_stores.retrieve.return_value

    @patch("ai_assistant_manager.clients.openai_api.time")
    def test_vector_stores_create(self, mock_time):
        file_ids = ["file_id"]
        name = "vector_store_name"
        self.mock_open_ai.beta.vector_stores.retrieve.side_effect = [
            MagicMock(status="pending", file_counts=MagicMock(failed=0)),
            MagicMock(status="completed", file_counts=MagicMock(failed=0)),
        ]

        vector_store_id = self.client.vector_stores_create(name, file_ids)

        self.mock_open_ai.beta.vector_stores.create.assert_called_once_with(name=name, file_ids=file_ids)
        assert vector_store_id == self.mock_open_ai.beta.vector_stores.create.return_value.id
        assert mock_time.sleep.call_count == 1

    @patch("ai_assistant_manager.clients.openai_api.logger")
    def test_vector_stores_create_with_failed_files(self, mock_logger):
        file_ids = ["file_id"]
        name = "vector_store_name"
        self.mock_open_ai.beta.vector_stores.retrieve.side_effect = [
            MagicMock(status="completed", file_counts=MagicMock(failed=1)),
        ]

        self.client.vector_stores_create(name, file_ids)

        self.mock_open_ai.beta.vector_stores.create.assert_called_once_with(name=name, file_ids=file_ids)
        assert mock_logger.warning.call_count == 1

    @patch("ai_assistant_manager.clients.openai_api.time")
    @patch("ai_assistant_manager.clients.openai_api.logger")
    def test_vector_stores_update(self, mock_logger, mock_time):
        expected_vector_store_id = "vector_store_id"
        file_ids = ["file_id"]

        self.mock_open_ai.beta.vector_stores.retrieve.side_effect = [
            MagicMock(status="pending", file_counts=MagicMock(failed=0)),
            MagicMock(status="completed", file_counts=MagicMock(failed=1)),
        ]

        vector_store_id = self.client.vector_stores_update(expected_vector_store_id, file_ids)

        self.mock_open_ai.beta.vector_stores.files.create.assert_called_once_with(vector_store_id, file_id=file_ids[0])

        # self.mock_open_ai.beta.vector_stores.create.assert_called_once_with(name=name, file_ids=file_ids)
        assert vector_store_id == expected_vector_store_id
        assert mock_time.sleep.call_count == 1
        assert mock_logger.warning.call_count == 1

    def test_vector_stores_delete(self):
        vector_store_id = "vector_store_id"

        self.client.vector_stores_delete(vector_store_id)

        self.mock_open_ai.beta.vector_stores.delete.assert_called_once_with(vector_store_id)

    def test_vector_stores_file_delete(self):
        vector_store_id = "vector_store_id"
        file_id = "file_id"

        self.client.vector_stores_file_delete(vector_store_id, file_id)
        self.mock_open_ai.beta.vector_stores.files.delete.assert_called_once_with(
            file_id, vector_store_id=vector_store_id
        )
        self.mock_open_ai.files.delete.assert_called_once_with(file_id)

    def test_vector_stores_files(self):
        vector_store_id = "vector_store_id"

        vector_store_files = self.client.vector_stores_files(vector_store_id)

        self.mock_open_ai.beta.vector_stores.files.list.assert_called_once_with(vector_store_id, limit=100)
        assert vector_store_files == self.mock_open_ai.beta.vector_stores.files.list.return_value

```

## openai_api.py

### Summary

This code defines an `OpenAIClient` class and associated functions for interacting with the OpenAI API. It includes methods for managing threads, messages, runs, assistants, files, and vector stores with timer decorators for performance monitoring. The `build_openai_client` function creates an OpenAI client instance with a 90-second timeout. The `OpenAIClient` class provides methods to create, retrieve, list, update, and delete various resources using the OpenAI API, including threads, messages, runs, assistants, files, and vector stores.

```py
import time
from io import BufferedReader
from typing import Literal

from loguru import logger
from openai import OpenAI

from ai_assistant_manager.env_variables import OPENAI_MODEL
from ai_assistant_manager.timer.timer import timer


def build_openai_client():
    """
    Build and return an OpenAI client with a specified timeout.

    :return: An instance of OpenAI client with a 90-second timeout.
    """
    return OpenAI(timeout=90)


class OpenAIClient:
    """
    A client class to interact with the OpenAI API, providing various methods to manage threads,
    messages, runs, assistants, files, and vector stores.
    """

    def __init__(self, open_ai: OpenAI, *, open_ai_model: str = OPENAI_MODEL):
        """
        Initialize the OpenAIClient with an OpenAI instance.

        :param open_ai: An instance of the OpenAI client.
        """
        self.open_ai = open_ai
        self.open_ai_model = open_ai_model

    @timer("OpenAIClient.threads_create")
    def threads_create(self):
        """
        Create a new thread using the OpenAI API.

        :return: The created thread object.
        """
        return self.open_ai.beta.threads.create()

    @timer("OpenAIClient.messages_list")
    def messages_list(self, thread_id: str):
        """
        List all messages in a specified thread.

        :param thread_id: The ID of the thread to list messages from.
        :return: A list of messages in the thread.
        """
        return self.open_ai.beta.threads.messages.list(thread_id)

    @timer("OpenAIClient.messages_create")
    def messages_create(self, thread_id: str, content: str, role: Literal["user", "assistant"]):
        """
        Create a new message in a specified thread.

        :param thread_id: The ID of the thread to create a message in.
        :param content: The content of the message.
        :param role: The role of the message sender (either "user" or "assistant").
        :return: The created message object.
        """
        return self.open_ai.beta.threads.messages.create(
            thread_id=thread_id,
            content=content,
            role=role,
        )

    @timer("OpenAIClient.runs_create")
    def runs_create(self, assistant_id: str, thread_id: str, should_force_tool_call: bool):
        """
        Create and poll a new run in a specified thread.

        :param assistant_id: The ID of the assistant to create a run for.
        :param thread_id: The ID of the thread to create a run in.
        :param should_force_tool_call: Whether to force a tool call during the run.
        :return: The created run object.
        """
        return self.open_ai.beta.threads.runs.create_and_poll(
            assistant_id=assistant_id,
            thread_id=thread_id,
            tool_choice={"type": "file_search"} if should_force_tool_call else None,
        )

    @timer("OpenAIClient.runs_retrieve")
    def runs_retrieve(self, run_id: str, thread_id: str):
        """
        Retrieve a specific run in a specified thread.

        :param run_id: The ID of the run to retrieve.
        :param thread_id: The ID of the thread the run belongs to.
        :return: The retrieved run object.
        """
        return self.open_ai.beta.threads.runs.retrieve(run_id, thread_id=thread_id)

    @timer("OpenAIClient.assistants_list")
    def assistants_list(self):
        """
        List all assistants.

        :return: A list of assistants.
        """
        return self.open_ai.beta.assistants.list()

    @timer("OpenAIClient.assistants_create")
    def assistants_create(
        self,
        name: str,
        instructions: str,
        vector_store_ids: list[str],
        tools: list[dict] = None,
    ):
        """
        Create a new assistant with specified parameters.

        :param name: The name of the assistant.
        :param instructions: The instructions for the assistant.
        :param vector_store_ids: A list of vector store IDs associated with the assistant.
        :param tools: A list of tools to be used by the assistant (optional).
        :return: The created assistant object.
        """
        return self.open_ai.beta.assistants.create(
            name=name,
            instructions=instructions,
            model=self.open_ai_model,
            tool_resources={"file_search": {"vector_store_ids": vector_store_ids}},
            tools=tools,
        )

    @timer("OpenAIClient.assistants_delete")
    def assistants_delete(self, assistant_id: str):
        """
        Delete a specified assistant.

        :param assistant_id: The ID of the assistant to delete.
        """
        self.open_ai.beta.assistants.delete(assistant_id)

    @timer("OpenAIClient.files_list")
    def files_list(self):
        """
        List all files.

        :return: A list of files.
        """
        return self.open_ai.files.list()

    @timer("OpenAIClient.files_get")
    def files_get(self, file_id: str):
        """
        Retrieve a specific file.

        :param file_id: The ID of the file to retrieve.
        :return: The retrieved file object.
        """
        return self.open_ai.files.retrieve(file_id)

    @timer("OpenAIClient.files_create")
    def files_create(self, file: BufferedReader, purpose: Literal["assistants", "batch", "fine-tune"]):
        """
        Create a new file with a specified purpose.

        :param file: The file to be uploaded.
        :param purpose: The purpose of the file (e.g., "assistants", "batch", "fine-tune").
        :return: The created file object.
        """
        return self.open_ai.files.create(file=file, purpose=purpose)

    @timer("OpenAIClient.files_delete")
    def files_delete(self, file_id: str):
        """
        Delete a specified file.

        :param file_id: The ID of the file to delete.
        """
        self.open_ai.files.delete(file_id)

    @timer("OpenAIClient.vector_stores_list")
    def vector_stores_list(self):
        """
        List all vector stores.

        :return: A list of vector stores.
        """
        return self.open_ai.beta.vector_stores.list()

    @timer("OpenAIClient.vector_stores_retrieve")
    def vector_stores_retrieve(self, vector_store_id: str):
        """
        Retrieve a specific vector store.

        :param vector_store_id: The ID of the vector store to retrieve.
        :return: The retrieved vector store object.
        """
        return self.open_ai.beta.vector_stores.retrieve(vector_store_id)

    @timer("OpenAIClient.vector_stores_create")
    def vector_stores_create(self, name: str, file_ids: list[str]):
        """
        Create a new vector store with specified parameters.

        :param name: The name of the vector store.
        :param file_ids: A list of file IDs to be included in the vector store.
        :return: The ID of the created vector store.
        """
        created_vector_store = self.open_ai.beta.vector_stores.create(name=name, file_ids=file_ids)
        vector_store_id = created_vector_store.id

        # Poll the vector store until its status is "completed"
        while (vector_store := self.vector_stores_retrieve(vector_store_id)).status != "completed":
            logger.info("Waiting for vector store to be ready")
            time.sleep(5)

        if vector_store.file_counts.failed > 0:
            logger.warning(
                f"Some files ({vector_store.file_counts.failed}) failed when uploaded to vector store ({vector_store_id})"
            )

        return vector_store_id

    @timer("OpenAIClient.vector_stores_update")
    def vector_stores_update(self, vector_store_id: str, file_ids: list[str]):
        """
        Update a vector store by adding new files to it.

        :param vector_store_id: The ID of the vector store to update.
        :param file_ids: A list of file IDs to add to the vector store.
        :return: The ID of the updated vector store.
        """
        # Add each file to the vector store
        [self.open_ai.beta.vector_stores.files.create(vector_store_id, file_id=file_id) for file_id in file_ids]

        # Poll the vector store until its status is "completed"
        while (vector_store := self.vector_stores_retrieve(vector_store_id)).status != "completed":
            logger.info("Waiting for vector store to be ready")
            time.sleep(5)

        if vector_store.file_counts.failed > 0:
            logger.warning(
                f"Some files ({vector_store.file_counts.failed}) failed when uploaded to vector store ({vector_store_id})"
            )
        return vector_store_id

    @timer("OpenAIClient.vector_stores_delete")
    def vector_stores_delete(self, vector_store_id: str):
        """
        Delete a specified vector store.

        :param vector_store_id: The ID of the vector store to delete.
        """
        self.open_ai.beta.vector_stores.delete(vector_store_id)

    @timer("OpenAIClient.vector_stores_file_delete")
    def vector_stores_file_delete(self, vector_store_id: str, file_id: str):
        """
        Delete a specific file from a vector store and also delete the file itself.

        :param vector_store_id: The ID of the vector store.
        :param file_id: The ID of the file to delete.
        """
        self.open_ai.beta.vector_stores.files.delete(file_id, vector_store_id=vector_store_id)
        self.files_delete(file_id)

    @timer("OpenAIClient.vector_stores_files")
    def vector_stores_files(self, vector_store_id: str):
        """
        List all files in a specified vector store.

        :param vector_store_id: The ID of the vector store to list files from.
        :return: A list of files in the vector store.
        """
        return self.open_ai.beta.vector_stores.files.list(vector_store_id, limit=100)

```

## chat.py

### Summary

This code defines a `Chat` class to manage interactions with an AI assistant using the OpenAI API. The functionality includes:

1. **Initialization**: The constructor `__init__()` accepts an OpenAIClient instance, an assistant ID, and optionally a thread ID.
2. **Start**: The `start()` method initializes a new chat thread if it doesn't exist.
3. **Send User Message**: The `send_user_message()` method sends a user message, potentially forces a tool call, runs the thread, and returns the last message content.
4. **Run Thread**: The `run_thread()` method executes the chat thread and can force a tool call.
5. **Wait for Run Completion**: The `_wait_for_run_to_complete()` method waits for a run to complete by polling at intervals.
6. **Retrieve Last Message**: The `last_message()` method retrieves the content of the last message.
7. **Get Messages**: The `_get_messages()` method retrieves all messages from the chat thread.
8. **Remove Tool Call Prefix**: The `remove_tool_call_from_message()` method strips a predefined tool call prefix from messages.
9. **Check for Tool Call**: The `should_force_tool_call()` method checks if the message starts with the tool call prefix.

Logging and timing functions are integrated to monitor the process and execution time.

```py
import time

from loguru import logger

from ai_assistant_manager.clients.openai_api import OpenAIClient
from ai_assistant_manager.timer.timer import timer

TOOL_CALL_PREFIX = "tc!"


class Chat:
    """
    A class to manage chat interactions with an AI assistant. This class handles the creation of threads,
    sending messages, running threads, and retrieving messages.
    """

    client: OpenAIClient
    assistant_id: str
    thread_id: str | None

    def __init__(
        self,
        client: OpenAIClient,
        assistant_id: str,
        *,
        thread_id: str | None = None,
    ):
        """
        Initialize the Chat instance with a client, assistant ID, and optional thread ID.

        :param client: The OpenAIClient instance to interact with the OpenAI API.
        :param assistant_id: The ID of the assistant to interact with.
        :param thread_id: The ID of the thread to use (optional).
        """
        self.client = client
        self.assistant_id = assistant_id
        self.thread_id = thread_id

    def start(self):
        """
        Start a new chat thread if one does not already exist.

        This method ensures that a thread ID is available for the chat session.
        """
        logger.info("Starting Chat")
        # Create a new thread if thread_id is not already set
        self.thread_id = self.thread_id or self.client.threads_create().id
        logger.info(f"Thread ID: {self.thread_id}")

    def send_user_message(self, message: str):
        """
        Send a user message to the chat thread and run the thread.

        :param message: The message content to send.
        :return: The last message content from the thread.
        """
        # Send the user message to the thread
        self.client.messages_create(
            self.thread_id,
            self.remove_tool_call_from_message(message),
            "user",
        )
        # Run the thread, potentially forcing a tool call
        self.run_thread(self.should_force_tool_call(message))
        return self.last_message()

    @timer("Run Thread")
    def run_thread(self, should_force_tool_call: bool):
        """
        Run the thread, potentially forcing a tool call.

        :param should_force_tool_call: Whether to force a tool call during the run.
        """
        run = self.client.runs_create(self.assistant_id, self.thread_id, should_force_tool_call)
        self._wait_for_run_to_complete(run.id)

    def _wait_for_run_to_complete(self, run_id: str, *, step: float = 0.25, timeout_in_seconds: int = 120):
        """
        Wait for a run to complete, polling at regular intervals.

        :param run_id: The ID of the run to wait for.
        :param step: The polling interval in seconds.
        :param timeout_in_seconds: The maximum time to wait in seconds.
        :raises RuntimeError: If the run fails or times out.
        """
        timeout = timeout_in_seconds / step

        while timeout > 0:
            run = self.client.runs_retrieve(run_id, self.thread_id)

            if run.status in ["completed"]:
                return
            # requires_action will need to be handled by user
            if run.status in ["failed", "expired", "cancelled", "requires_action"]:
                raise RuntimeError(f"Run failed with status: {run.status}")

            timeout -= 1
            time.sleep(step)

        raise RuntimeError(f"Run timed out after {timeout_in_seconds} seconds")

    def last_message(self) -> str:
        """
        Retrieve the last message content from the thread.

        :return: The content of the last message.
        :raises RuntimeError: If no text content is found in the messages.
        """
        message_content = self._get_messages()[0].content[0]
        if hasattr(message_content, "text"):
            return message_content.text.value

        raise RuntimeError("No text content found in the messages")

    def _get_messages(self):
        """
        Retrieve all messages from the thread.

        :return: A list of messages in the thread.
        """
        return self.client.messages_list(self.thread_id).data

    def remove_tool_call_from_message(self, message):
        """
        Remove the tool call prefix from the message if it exists.

        :param message: The message content to process.
        :return: The message content without the tool call prefix.
        """
        return message.replace(TOOL_CALL_PREFIX, "", 1) if self.should_force_tool_call(message) else message

    def should_force_tool_call(self, message):
        """
        Determine if the message should force a tool call.

        :param message: The message content to check.
        :return: True if the message starts with the tool call prefix, False otherwise.
        """
        return message.startswith(TOOL_CALL_PREFIX)

```

## chat_test.py

### Summary

This code is a unit test suite for a `Chat` class within the `ai_assistant_manager.chats.chat` module. The tests use the `unittest` and `pytest` frameworks along with `MagicMock` for mocking dependencies. Here's a brief summary of what each test does:

1. **`TestChat` Class Initialization**: Initializes `Chat` with mocked client and defines `assistant_id`.

2. **`setUp` Method**: Prepares a `MagicMock` client and initializes a `Chat` instance before each test.

3. **`test_chat_start_sets_thread_id`**: Verifies that calling `start` on `Chat` sets the `thread_id`.

4. **`test_chat_start_with_thread`**: Ensures that `start` does not overwrite an existing `thread_id`.

5. **`test_send_user_message`**: Tests that a user message is sent, and the response is handled correctly.

6. **`test_chat_run_thread`**: Checks the `run_thread` method and its interaction with `_wait_for_run_to_complete`.

7. **`test_wait_for_run_to_complete_success`**: Validates successful completion handling in `_wait_for_run_to_complete`.

8. **`test_wait_for_run_to_complete_failure`**: Tests handling of a failed run in `_wait_for_run_to_complete`.

9. **`test_wait_for_run_to_complete_timeout`**: Verifies timeout handling in `_wait_for_run_to_complete`.

10. **`test_last_message`**: Asserts that `last_message` retrieves the correct last message content.

11. **`test_last_message_with_text_content`**: Ensures `last_message` handles messages with `TextContentBlock`.

12. **`test_last_message_with_no_text_content`**: Checks error handling when no text content is found.

13. **`test_remove_tool_call_from_message`**: Tests the removal of tool call indicators from messages.

14. **`test_should_force_tool_call`**: Ensures that tool call conditions are correctly identified.

```py
from unittest import TestCase
from unittest.mock import MagicMock, patch

import pytest
from openai.types.beta.threads.text import Text
from openai.types.beta.threads.text_content_block import TextContentBlock

from ai_assistant_manager.chats.chat import Chat


class TestChat(TestCase):
    chat: Chat
    assistant_id = "assistant_id"

    mock_client: MagicMock

    def setUp(self):
        self.mock_client = MagicMock()
        self.chat = Chat(self.mock_client, self.assistant_id)

    def test_chat_start_sets_thread_id(self):
        self.mock_client.threads_create.return_value.id = "thread_id"

        self.chat.start()

        assert self.chat.thread_id == "thread_id"

    def test_chat_start_with_thread(self):
        self.chat.thread_id = "my_thread_id"

        self.chat.start()

        assert self.chat.thread_id == "my_thread_id"

    def test_send_user_message(self):
        self.mock_client.messages_create.return_value = None
        self.mock_client.messages_list.return_value.data = [{"content": "Hello"}]
        self.chat.thread_id = "thread_id"
        self.chat.run_thread = MagicMock()
        self.chat.last_message = MagicMock(return_value="Hello")

        result = self.chat.send_user_message("Test message")

        assert result == "Hello"
        self.mock_client.messages_create.assert_called_once_with("thread_id", "Test message", "user")
        self.chat.run_thread.assert_called_once()
        self.chat.last_message.assert_called_once()

    def test_chat_run_thread(self):
        self.mock_client.runs_create.return_value.id = "run_id"
        self.chat.thread_id = "thread_id"

        with patch.object(self.chat, "_wait_for_run_to_complete") as mock_wait_for_run_to_complete:
            self.chat.run_thread(False)

        mock_wait_for_run_to_complete.assert_called_once_with("run_id")

    def test_wait_for_run_to_complete_success(self):
        self.mock_client.runs_retrieve.return_value.status = "completed"

        with patch("time.sleep", return_value=None):
            # pylint: disable=protected-access
            self.chat._wait_for_run_to_complete("run_id")

        self.mock_client.runs_retrieve.assert_called_with(
            "run_id",
            self.chat.thread_id,
        )

    def test_wait_for_run_to_complete_failure(self):
        self.mock_client.runs_retrieve.return_value.status = "failed"

        with patch("time.sleep", return_value=None):
            with pytest.raises(RuntimeError, match="Run failed with status: failed"):
                # pylint: disable=protected-access
                self.chat._wait_for_run_to_complete("run_id")

        self.mock_client.runs_retrieve.assert_called_with(
            "run_id",
            self.chat.thread_id,
        )

    def test_wait_for_run_to_complete_timeout(self):
        self.mock_client.runs_retrieve.return_value.status = "running"

        with patch("time.sleep", return_value=None):
            with pytest.raises(RuntimeError, match="Run timed out after 1 seconds"):
                # pylint: disable=protected-access
                self.chat._wait_for_run_to_complete("run_id", timeout_in_seconds=1)

        self.mock_client.runs_retrieve.assert_called_with(
            "run_id",
            self.chat.thread_id,
        )

    def test_last_message(self):
        self.mock_client.messages_list.return_value.data = [
            MagicMock(content=[MagicMock(text=MagicMock(value="Hello"))])
        ]
        self.chat.thread_id = "thread_id"

        result = self.chat.last_message()

        assert result == "Hello"
        self.mock_client.messages_list.assert_called_once_with("thread_id")

    def test_last_message_with_text_content(self):
        self.chat._get_messages = MagicMock(
            return_value=[
                MagicMock(content=[TextContentBlock(text=Text(annotations=[], value="Hello, world!"), type="text")])
            ]
        )
        assert self.chat.last_message() == "Hello, world!"

    def test_last_message_with_no_text_content(self):
        not_text = MagicMock()
        delattr(not_text, "text")
        self.chat._get_messages = MagicMock(return_value=[MagicMock(content=[not_text])])
        with pytest.raises(RuntimeError, match="No text content found in the messages"):
            self.chat.last_message()

    def test_remove_tool_call_from_message(self):
        assert self.chat.remove_tool_call_from_message("tc! call") == " call"
        assert self.chat.remove_tool_call_from_message(" tc! call") == " tc! call"

    def test_should_force_tool_call(self):
        assert self.chat.should_force_tool_call("tc!")
        assert not self.chat.should_force_tool_call(" tc!")

```

## env_variables.py

### Summary

This Python code loads environment variables from a `.env` file using the `dotenv` library. If specific variables aren't found in the environment, it sets default values for these variables:

- `OPENAI_MODEL` defaults to "gpt-4o".
- `ASSISTANT_DESCRIPTION` defaults to "AI Assistant Manager".
- `ASSISTANT_NAME` defaults to "AI Assistant Manager".
- `BIN_DIR` defaults to "bin".
- `DATA_DIR` defaults to "data".
- `DATA_FILE_PREFIX` defaults to "AI Assistant Manager".

```py
import os

from dotenv import load_dotenv

load_dotenv()


OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o")

ASSISTANT_DESCRIPTION = os.getenv("ASSISTANT_DESCRIPTION", "AI Assistant Manager")
ASSISTANT_NAME = os.getenv("ASSISTANT_NAME", "AI Assistant Manager")
BIN_DIR = os.getenv("BIN_DIR", "bin")
DATA_DIR = os.getenv("DATA_DIR", "data")
DATA_FILE_PREFIX = os.getenv("DATA_FILE_PREFIX", "AI Assistant Manager")

```

## assistant_service.py

### Summary

The given Python code defines an `AssistantService` class that manages AI assistants, vector stores, and retrieval files using an `OpenAIClient` instance. Here's a summary of its main components:

1. **Initialization**:
   - Takes the `OpenAIClient`, prompt, assistant name, data file prefix, and retrieval tools as inputs.
2. **Assistant Management**:

   - `get_assistant_id()`: Retrieves or creates an assistant and returns its ID.
   - `_find_existing_assistant()`: Checks for an existing assistant by name.
   - `_create_assistant()`: Creates a new assistant if none exists.

3. **Vector Store Management**:

   - `get_vector_store_ids()`: Retrieves or creates vector store IDs.
   - `_find_existing_vector_stores()`: Check for existing vector stores by data file prefix.
   - `create_vector_stores()`: Creates new vector stores.
   - `_validate_vector_stores()`: Validates and recreates failed files in a vector store.

4. **File Management**:

   - `get_retrieval_file_ids()`: Retrieves or creates retrieval file IDs.
   - `_find_existing_retrieval_files()`: Checks for existing files by data file prefix.
   - `create_retrieval_files()`: Creates new retrieval files.
   - `_get_file_paths()`: Gets paths of all files in the "bin" directory.
   - `_create_files()` and `_create_file()`: Create files using the client.

5. **Cleanup**:
   - `delete_assistant()`: Deletes the assistant along with its vector stores and retrieval files.

The class manages resources by interacting with OpenAI's APIs and ensures that all operations, such as validation and cleanup, are handled efficiently.

```py
import os

from loguru import logger

from ai_assistant_manager.clients.openai_api import OpenAIClient
from ai_assistant_manager.env_variables import ASSISTANT_NAME, DATA_FILE_PREFIX

RETRIEVAL_TOOLS = [
    {"type": "file_search"},
]


class AssistantService:
    """
    Service class to manage AI assistants and their associated vector stores and files.
    This class interacts with the OpenAIClient to perform operations such as creating,
    finding, and deleting assistants and their related resources.
    """

    def __init__(
        self,
        client: OpenAIClient,
        prompt: str,
        *,
        assistant_name: str = ASSISTANT_NAME,
        data_file_prefix: str = DATA_FILE_PREFIX,
        tools: list[dict] = RETRIEVAL_TOOLS,
    ):
        """
        Initialize the AssistantService with a client, prompt, assistant name, and data file prefix.

        :param client: The OpenAIClient instance to interact with the OpenAI API.
        :param prompt: The prompt to be used for the assistant.
        :param assistant_name: The name of the assistant (default is from environment variables).
        :param data_file_prefix: The prefix for data files (default is from environment variables).
        :param tools: The tools to be used by the assistant.
        """
        self.client = client
        self.prompt = prompt
        self.data_file_prefix = data_file_prefix
        self.assistant_name = assistant_name
        self.tools = tools

    def get_assistant_id(self):
        """
        Get the assistant ID, either by finding an existing one or creating a new one.

        :return: The ID of the assistant.
        """
        return self._find_existing_assistant() or self._create_assistant()

    def _find_existing_assistant(self):
        """
        Retrieve the list of assistants and find one that matches the assistant name.

        :return: The ID of the existing assistant or None if not found.
        """
        assistants = self.client.assistants_list()
        return next(
            (assistant.id for assistant in assistants if assistant.name == self.assistant_name),
            None,
        )

    def _create_assistant(self):
        """
        Create a new assistant using the client if no existing assistant is found.

        :return: The ID of the newly created assistant.
        """
        logger.info(f"Creating new assistant {self.assistant_name}")
        return self.client.assistants_create(
            self.assistant_name, self.prompt, self.get_vector_store_ids(), tools=self.tools
        ).id

    def get_vector_store_ids(self):
        """
        Get the vector store IDs, either by finding existing ones or creating new ones.

        :return: A list of vector store IDs.
        """
        return self._find_existing_vector_stores() or self.create_vector_stores()

    def _find_existing_vector_stores(self):
        """
        Retrieve the list of vector stores and find those that match the data file prefix.

        :return: A list of existing vector store IDs.
        """
        vector_stores = self.client.vector_stores_list()
        return [
            vector_store.id
            for vector_store in vector_stores
            if vector_store.name and vector_store.name.startswith(self.data_file_prefix)
        ]

    def create_vector_stores(self):
        """
        Create new vector stores if no existing vector stores are found.

        :return: A list containing the ID of the newly created vector store.
        """
        logger.info("Creating new vector stores")
        retrieval_file_ids = self.get_retrieval_file_ids()
        return [
            self._validate_vector_stores(
                self.client.vector_stores_create(f"{self.data_file_prefix} vector store", retrieval_file_ids)
            )
        ]

    def _validate_vector_stores(self, vector_store_id: str):
        """
        Validate the vector store by checking the status of its files and recreating any failed files.

        :param vector_store_id: The ID of the vector store to validate.
        :return: The validated vector store ID.
        """
        try:
            vector_store_files = self.client.vector_stores_files(vector_store_id)
            failed_files = [file.id for file in vector_store_files if file.status == "failed"]

            if not failed_files:
                return vector_store_id

            # Retrieve details of failed files
            failed_retrieval_files = [self.client.files_get(file) for file in failed_files if file]
            failed_retrieval_file_names = [self._get_file_name(file.filename) for file in failed_retrieval_files]
            failed_file_paths = [
                file_path
                for file_path in self._get_file_paths()
                if self._get_file_name(file_path) in failed_retrieval_file_names
            ]

            # Delete failed files from vector store
            [self.client.vector_stores_file_delete(vector_store_id, file_id) for file_id in failed_files]

            # Recreate failed files
            recreated_files = self._create_files(failed_file_paths)
            self.client.vector_stores_update(vector_store_id, recreated_files)

            # Recursively validate the vector store again
            return self._validate_vector_stores(vector_store_id)
        except Exception as e:
            logger.error(f"Error validating vector store {vector_store_id}: {e}")
            return self._validate_vector_stores(vector_store_id)

    def _get_file_name(self, file_path: str) -> str:
        """
        Extract the file name from the file path.

        :param file_path: The path of the file.
        :return: The name of the file.
        """
        return os.path.basename(file_path)

    def get_retrieval_file_ids(self):
        """
        Get the retrieval file IDs, either by finding existing ones or creating new ones.

        :return: A list of retrieval file IDs.
        """
        return self._find_existing_retrieval_files() or self.create_retrieval_files()

    def _find_existing_retrieval_files(self):
        """
        Retrieve the list of files and find those that match the data file prefix.

        :return: A list of existing retrieval file IDs.
        """
        files = self.client.files_list()
        return [file.id for file in files if file.filename.startswith(self.data_file_prefix)]

    def create_retrieval_files(self):
        """
        Create new retrieval files if no existing retrieval files are found.

        :return: A list of newly created retrieval file IDs.
        """
        logger.info("Creating new retrieval files")
        file_paths = self._get_file_paths()
        return self._create_files(file_paths)

    def _get_file_paths(self):
        """
        Get the paths of all files in the "bin" directory, excluding ".DS_Store" files.

        :return: A list of file paths.
        """
        return [
            os.path.join(root, file)
            for (root, _, files) in os.walk("bin")
            for file in files
            if not file.endswith(".DS_Store")
        ]

    def _create_files(self, file_paths: list[str]):
        """
        Create files using the client for each file path provided.

        :param file_paths: A list of file paths to create files from.
        :return: A list of newly created file IDs.
        """
        return [self._create_file(file_path) for file_path in file_paths]

    def _create_file(self, file_path: str):
        """
        Create a single file using the client.

        :param file_path: The path of the file to create.
        :return: The ID of the newly created file.
        """
        with open(file_path, "rb") as file:
            return self.client.files_create(file, "assistants").id

    def delete_assistant(self):
        """
        Remove the assistant and its associated vector stores and retrieval files.

        This method ensures that all resources related to the assistant are cleaned up.
        """
        logger.info(f"Removing existing {self.assistant_name} and retrieval files")

        if assistant_id := self._find_existing_assistant():
            self.client.assistants_delete(assistant_id)
        if vector_store_ids := self._find_existing_vector_stores():
            for vector_store_id in vector_store_ids:
                self.client.vector_stores_delete(vector_store_id)
        if file_ids := self._find_existing_retrieval_files():
            for file_id in file_ids:
                self.client.files_delete(file_id)

```

## ruff_defaults.toml

### Summary

This code configures several formatting and linting rules:

- Sets the maximum line length to 120.
- Enforces specific formats for docstrings with a code line length of 80.
- Disallows all relative imports in flake8-tidy-imports.
- Configures isort to recognize "src" as a first-party import.
- Specifies flake8-pytest-style preferences, disabling the use of parentheses for fixtures and marks.

```toml
line-length = 120

[format]
docstring-code-format = true
docstring-code-line-length = 80

[lint.flake8-tidy-imports]
ban-relative-imports = "all"

[lint.isort]
known-first-party = ["src"]

[lint.flake8-pytest-style]
fixture-parentheses = false
mark-parentheses = false
```

## run_end_to_end.py

### Summary

This code sets up and tests an AI assistant managed by the `AI-Assistant-Manager` package. Here's what it does:

1. Logs and exports a file named `about.txt`.
2. Initializes the AI assistant with the name "AI-Assistant-Manager-Test".
3. Creates an OpenAI client and an AssistantService, which is responsible for handling the assistant.
4. Deletes any existing assistant and prints the new assistant ID.
5. Starts a chat session with the assistant and sends a test message asking, "What is the AI Assistant Manager?".
6. Prints the response from the assistant.
7. Removes the assistant after the interaction.
8. Handles any exceptions by logging the error message.

```py
from loguru import logger

from ai_assistant_manager.assistants.assistant_service import (
    AssistantService,
)
from ai_assistant_manager.chats.chat import Chat
from ai_assistant_manager.clients.openai_api import OpenAIClient, build_openai_client
from ai_assistant_manager.exporters.files.files_exporter import FilesExporter


def main():
    FilesExporter("about.txt").export()

    assistant_name = "AI-Assistant-Manager-Test"
    logger.info(f"Building {assistant_name}")

    client = OpenAIClient(build_openai_client())
    service = AssistantService(client, "You are a helpful assistant")

    logger.info("Removing existing assistant and category files")
    service.delete_assistant()

    assistant_id = service.get_assistant_id()
    logger.info(f"Assistant ID: {assistant_id}")

    chat = Chat(client, assistant_id)
    chat.start()

    message = "What is the AI Assistant Manager?"
    print(f"\nMessage:\n{message}")

    start_response = chat.send_user_message(message)
    print(f"\n{service.assistant_name}:\n{start_response}")

    service.delete_assistant()


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.info(f"Error: {e}")

```

## files_exporter.py

### Summary

This code defines a `FilesExporter` class for handling the export of files to a specified directory. It ensures files are only exported if they don't already exist and manages the necessary directory creation. The class constructor initializes file and directory information. The `export` method checks for file existence and skips export if the file exists, otherwise, it proceeds to write the data. The `write_data` method copies the source file to the target path. Utility methods like `get_dir_path`, `get_file_path`, and `_get_file_name_without_extension` assist in path construction and file name handling. Logging is used extensively to track operations.

```py
import os
import shutil

from loguru import logger

from ai_assistant_manager.env_variables import BIN_DIR, DATA_DIR, DATA_FILE_PREFIX
from ai_assistant_manager.exporters.exporter import (
    create_dir,
    does_data_exist,
)


class FilesExporter:
    """
    A class to handle exporting files to a specified directory.

    This class ensures that files are only exported if they do not already exist,
    and it manages the creation of necessary directories.
    """

    def __init__(
        self,
        file_name: str,
        *,
        directory: str = "files",
        bin_dir: str = BIN_DIR,
        data_dir: str = DATA_DIR,
        data_file_prefix: str = DATA_FILE_PREFIX,
    ) -> None:
        """
        Initialize the FilesExporter with file and directory information.

        :param file_name: The name of the file to export.
        :param directory: The target directory for the export (default is "files").
        :param bin_dir: The base directory for binaries (default is from environment variables).
        :param data_dir: The base directory for data files (default is from environment variables).
        :param data_file_prefix: The prefix for data files (default is from environment variables).
        """
        self.file_name = file_name
        self.directory = directory
        self.bin_dir = bin_dir
        self.data_dir = data_dir
        self.data_file_prefix = data_file_prefix

    def export(self):
        """
        Export the file to the target directory if it does not already exist.

        This method checks for the existence of the file and skips the export if the file is already present.
        It also ensures that the necessary directory structure is created before writing the data.
        """
        if does_data_exist(self.get_file_path()):
            logger.info(f"{self._get_file_name_without_extension()} data exists. Skipping export.")
            return

        logger.info(f"Exporting {self._get_file_name_without_extension()} data")
        create_dir(self.get_dir_path(), self.get_file_path())
        self.write_data()

    def write_data(self):
        """
        Write the data to the target file path.

        This method copies the source file to the target file path and logs the operation.
        """
        source_path = os.path.join(self.data_dir, self.directory, self.file_name)
        shutil.copy(source_path, self.get_file_path())

        logger.info(f"{self._get_file_name_without_extension()} data written to file: {self.get_file_path()}")

    def get_dir_path(self):
        """
        Get the path to the target directory.

        :return: The path to the target directory.
        """
        return os.path.join(
            self.bin_dir,
            self.directory,
        )

    def get_file_path(self):
        """
        Get the full path to the target file.

        :return: The full path to the target file.
        """
        return os.path.join(
            self.get_dir_path(),
            f"{self.data_file_prefix}_{self.file_name}",
        )

    def _get_file_name_without_extension(self) -> str:
        """
        Get the file name without its extension.

        This method is used to log the file name without its extension for clarity.

        :return: The file name without its extension.
        """
        file_name_parts = os.path.basename(self.file_name)
        return os.path.splitext(file_name_parts)[0]

```
