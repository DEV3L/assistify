# assistify-api

## server.py

### Summary

This code runs a FastAPI application using Uvicorn on localhost (127.0.0.1) at port 8000 with auto-reload enabled.

```py
import uvicorn


def main():
    uvicorn.run("src.app.api:api", host="127.0.0.1", port=8000, reload=True)


if __name__ == "__main__":
    main()

```

## app_test.py

### Summary

This code consists of unit tests for a FastAPI application using the `TestClient` from `fastapi.testclient` and `unittest.mock.patch`. It tests three cases:

1. `test_read_root`: Checks if the root endpoint ("/") returns a 200 status code and a JSON message `"Hello Assistify"`.
2. `test_protected_route`: Mocks the `verify_token` function to return a user's information and ensures that accessing the "/protected" endpoint with a valid token returns a 200 status code and the correct greeting message.
3. `test_protected_route_unauthorized`: Checks if accessing the "/protected" endpoint with an invalid token returns a 401 status code.

```py
from unittest.mock import patch

from fastapi.testclient import TestClient

from .api import api

client = TestClient(api)


def test_read_root():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello Assistify"}


@patch("src.app.auth.verify_token.id_token")
def test_protected_route(mock_id_token):
    mock_user_info = {"name": "Test User", "email": "test@example.com", "iss": "accounts.google.com"}
    mock_id_token.verify_oauth2_token.return_value = mock_user_info

    response = client.get("/protected", headers={"Authorization": "Bearer fake_token"})

    assert response.status_code == 200
    assert response.json() == {"message": f"Hello {mock_user_info['name']}, your email is {mock_user_info['email']}"}


def test_protected_route_unauthorized():
    response = client.get("/protected", headers={"Authorization": "Bearer invalid_token"})

    assert response.status_code == 401

```

## timer_test.py

### Summary

This code defines a test for a `timer` decorator using the `unittest.mock` library. It checks that the `timer` decorator logs a debug message when a decorated dummy function is called. Specifically, it verifies that the log message is called once and contains the phrase "Test function: completed in".

```py
from unittest.mock import patch

from src.timer.timer import timer


def test_timer_decorator():
    @timer("Test function")
    def dummy_function():
        pass

    with patch("src.timer.timer.logger") as mock_logger:
        dummy_function()

    mock_logger.debug.assert_called_once()
    assert "Test function: completed in" in mock_logger.debug.call_args[0][0]

```

## Dockerfile

### Summary

This Dockerfile sets up a Python 3.12 environment for a project. It copies the app's code to the `/app` directory, installs dependencies using Hatch, and creates an environment. It exposes port 8000, sets an environment variable `NAME` to `AssistifyAPI`, and starts the app with the command `hatch run start-app`.

```
FROM python:3.12-slim

WORKDIR /app

COPY . /app

RUN pip install hatch
RUN hatch env create

EXPOSE 8000

# Define environment variable
ENV NAME AssistifyAPI

CMD ["hatch", "run", "start-app"]
```

## timer.py

### Summary

This code defines a decorator named `timer` which, when applied to a function, measures the function's execution time and logs a custom message along with the elapsed time using the Loguru logger.

```py
import time
from functools import wraps

from loguru import logger


def timer(message: str):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            elapsed_time = round(end_time - start_time, 4)
            logger.debug(f"{message}: completed in {elapsed_time} seconds")
            return result

        return wrapper

    return decorator

```

## verify_token_test.py

### Summary

This code is a set of unit tests for the `verify_token` function, using pytest and unittest.mock. It includes:

1. A pytest fixture named `mock_credentials` that returns mock authorization credentials.
2. `test_verify_token_valid`: Tests that `verify_token` returns the correct information for valid credentials.
3. `test_verify_token_invalid_issuer`: Tests that `verify_token` raises an HTTPException with a 401 status for an invalid issuer.
4. `test_verify_token_value_error`: An asynchronous test to check that `verify_token` raises an HTTPException with a 401 status when a ValueError occurs during token verification.

```py
from unittest.mock import patch

import pytest
from fastapi import HTTPException
from fastapi.security import HTTPAuthorizationCredentials

from .verify_token import verify_token


@pytest.fixture
def mock_credentials():
    return HTTPAuthorizationCredentials(scheme="Bearer", credentials="fake_token")


def test_verify_token_valid(mock_credentials):
    mock_idinfo = {"iss": "accounts.google.com", "sub": "123456789", "email": "test@example.com"}

    with patch("google.oauth2.id_token.verify_oauth2_token", return_value=mock_idinfo):
        result = verify_token(mock_credentials)
        assert result == mock_idinfo


def test_verify_token_invalid_issuer(mock_credentials):
    mock_idinfo = {"iss": "invalid.issuer.com", "sub": "123456789", "email": "test@example.com"}

    with patch("google.oauth2.id_token.verify_oauth2_token", return_value=mock_idinfo):
        with pytest.raises(HTTPException) as exc_info:
            verify_token(mock_credentials)
        assert exc_info.value.status_code == 401
        assert exc_info.value.detail == "Invalid authentication credentials"


@pytest.mark.asyncio
def test_verify_token_value_error(mock_credentials):
    with patch("google.oauth2.id_token.verify_oauth2_token", side_effect=ValueError("Invalid token")):
        with pytest.raises(HTTPException) as exc_info:
            verify_token(mock_credentials)
        assert exc_info.value.status_code == 401
        assert exc_info.value.detail == "Invalid authentication credentials"

```

## pyproject.toml

### Summary

This code is a configuration file for a Python project named "assistify-api," which is built using FastAPI and integrates with OpenAI's API. The configuration specifies using Hatchling for the build system and includes metadata like the project description, author, and required Python version (>=3.12). Dependencies include libraries like FastAPI, Loguru, and Uvicorn.

The configuration also details:

- Dynamic versioning from `setup.cfg`.
- Build targets for source distribution and wheel packaging.
- Virtual environment setup with additional development dependencies like Pyright and Pytest.
- Custom scripts for development, starting the app, and running tests.
- Ruff and Pytest configurations for linting and integration test markers, respectively.

```toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "assistify-api"
dynamic = ["version"]
description = "A robust FastAPI application that integrates with OpenAI's API to facilitate seamless conversation capabilities through a RESTful interface."
readme = "README.md"
authors = [{ name = "Justin Beall", email = "jus.beall@gmail.com" }]
requires-python = ">=3.12"
dependencies = [
    "fastapi",
    "loguru",
    "google-auth",
    "openai",
    "python-dotenv",
    "uvicorn",
    "requests",
    "authlib",
]

[tool.hatch.version]
path = "setup.cfg"
pattern = "version = (?P<version>\\S+)"

[tool.hatch.build.targets.sdist]
include = ["/src"]

[tool.hatch.build.targets.wheel]
packages = ["src"]

[tool.hatch.envs.default]
type = "virtual"
path = ".venv"
dependencies = ["pyright", "pytest-cov", "pytest"]

[tool.hatch.envs.default.scripts]
dev = "python server.py"
start-app = "uvicorn src.app.api:api --host 0.0.0.0 --port 8000"
test = "pytest --cache-clear --cov --cov-report lcov --cov-report term"

[tool.hatch.envs.hatch-static-analysis]
config-path = "ruff_defaults.toml"

[tool.ruff]
extend = "ruff_defaults.toml"

[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "parents"

[tool.pytest.ini_options]
markers = "integration: an integration test that hits external uncontrolled systems"

```

## custom_cors_middleware_test.py

### Summary

This code sets up a FastAPI application with a custom CORS (Cross-Origin Resource Sharing) middleware and includes tests for CORS handling. Here's a summary:

1. **Setup FastAPI App**:

   - Creates a FastAPI app with a single endpoint (`/`) that returns a "Hello World" message.
   - Adds `CustomCORSMiddleware` to handle CORS configurations.

2. **Testing Configuration**:
   - Creates a test client for the FastAPI app using `TestClient`.
3. **CORS Tests**:
   - `test_cors_allowed_origin`: Verifies that specified origins (from a list) are allowed by checking if the appropriate CORS headers are returned.
   - `test_cors_disallowed_origin`: Ensures that a non-allowed origin does not have the CORS headers in the response.
   - `test_cors_preflight`: Checks a CORS preflight request to ensure the correct handling of HTTP Options requests, including allowed methods and headers.

The tests ensure that only the specified origins have proper CORS permissions for accessing the FastAPI application.

```py
import pytest
from fastapi import FastAPI
from starlette.testclient import TestClient

from .custom_cors_middleware import CustomCORSMiddleware

app = FastAPI()


@app.get("/")
async def read_main():
    return {"msg": "Hello World"}


# Add the custom middleware to the app
app.add_middleware(CustomCORSMiddleware)

client = TestClient(app)


@pytest.mark.parametrize(
    "origin",
    [
        "https://assistify.example.vercel.app",
        "https://assistify-ui.vercel.app",
        "https://assistify-ui-ci.vercel.app",
        "https://assistify-api.fly.dev",
        "https://assistify-api-ci.fly.dev",
        "http://localhost:3000",
    ],
    ids=["assistify_example", "assistify_ui", "assistify_ui_ci", "assistify_api", "assistify_api_ci", "localhost:3000"],
)
def test_cors_allowed_origin(origin: str):
    response = client.get("/", headers={"origin": origin})
    assert response.status_code == 200
    assert response.headers["Access-Control-Allow-Origin"] == origin
    assert response.headers["Access-Control-Allow-Credentials"] == "true"
    assert response.headers["Access-Control-Allow-Methods"] == "*"
    assert response.headers["Access-Control-Allow-Headers"] == "*"


def test_cors_disallowed_origin():
    response = client.get("/", headers={"origin": "https://notallowed.example.com"})
    assert response.status_code == 200
    assert "Access-Control-Allow-Origin" not in response.headers
    assert "Access-Control-Allow-Credentials" not in response.headers
    assert "Access-Control-Allow-Methods" not in response.headers
    assert "Access-Control-Allow-Headers" not in response.headers


def test_cors_preflight():
    response = client.options(
        "/protected",
        headers={
            "origin": "https://assistify-ui-ci.vercel.app",
            "Access-Control-Request-Method": "GET",
            "Access-Control-Request-Headers": "authorization",
        },
    )
    assert response.status_code == 200
    assert response.headers["Access-Control-Allow-Origin"] == "https://assistify-ui-ci.vercel.app"
    assert response.headers["Access-Control-Allow-Credentials"] == "true"
    assert response.headers["Access-Control-Allow-Methods"] == "GET, POST, OPTIONS"
    assert response.headers["Access-Control-Allow-Headers"] == "authorization, content-type"

```

## api.py

### Summary

This code defines a FastAPI application with three API endpoints. It includes custom CORS middleware and verifies tokens for protected routes.

1. `/` - Returns a welcome message.
2. `/random-number` - Returns a random number between 1 and 100.
3. `/protected` - Protected route that returns a personalized message for authenticated users, based on token verification.

```py
import random

from fastapi import Depends, FastAPI

from src.app.cors.custom_cors_middleware import CustomCORSMiddleware

from .auth.verify_token import verify_token

api = FastAPI()

api.add_middleware(CustomCORSMiddleware)


@api.get("/")
def read_root():
    return {"message": "Hello Assistify"}


@api.get("/random-number")
def read_random_number():
    number = random.randint(1, 100)
    return {"message": f"Your random number is {number}"}


@api.get("/protected")
def protected_route(user_info: dict = Depends(verify_token)):
    return {"message": f"Hello {user_info['name']}, your email is {user_info['email']}"}

```

## fly.toml

### Summary

This code outlines the configuration for deploying an app named "assistify-api" using Fly.io. It specifies:

- The app's name and primary region.
- HTTP service settings, including the internal port (8000), forced HTTPS, automatic stopping and starting of machines, and no minimum machines running.
- VM specifications: 1 GB of memory, shared CPU type, and 1 CPU.

```toml
# fly.toml app configuration file generated for fast-chat-api on 2024-07-13T21:38:35-04:00
#
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.
#

app = 'assistify-api'
primary_region = 'ewr'

[build]

[http_service]
internal_port = 8000
force_https = true
auto_stop_machines = true
auto_start_machines = true
min_machines_running = 0
processes = ['app']

[[vm]]
memory = '1gb'
cpu_kind = 'shared'
cpus = 1

```

## verify_token.py

### Summary

This FastAPI code snippet uses OAuth2 to verify Google tokens for authentication. It imports necessary libraries, loads environment variables, and defines a function `verify_token` that checks the validity of a provided Google token. If the token is invalid or from the wrong issuer, it raises an HTTP 401 Unauthorized error.

```py
import os

from dotenv import load_dotenv
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from google.auth.transport import requests
from google.oauth2 import id_token

load_dotenv()

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")

security = HTTPBearer()


def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    try:
        idinfo = id_token.verify_oauth2_token(token, requests.Request(), GOOGLE_CLIENT_ID)
        if idinfo["iss"] not in ["accounts.google.com", "https://accounts.google.com"]:
            raise ValueError("Wrong issuer.")
        return idinfo
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

```

## ruff_defaults.toml

### Summary

This code snippet is a configuration file for code formatting and linting settings:

- Sets a general line length limit of 120 characters.
- Specifies formatting rules for docstrings, enabling code formatting within docstrings and setting their maximum line length to 80 characters.
- Bans all relative imports in Python files for better import clarity.
- Recognizes the "src" directory as containing first-party imports.
- Disables the requirement for parentheses in pytest fixtures and marks.

```toml
line-length = 120

[format]
docstring-code-format = true
docstring-code-line-length = 80

[lint.flake8-tidy-imports]
ban-relative-imports = "all"

[lint.isort]
known-first-party = ["src"]

[lint.flake8-pytest-style]
fixture-parentheses = false
mark-parentheses = false
```

## custom_cors_middleware.py

### Summary

This code defines a custom CORS (Cross-Origin Resource Sharing) middleware for a FastAPI application. It dynamically sets CORS headers based on the request's origin. If the origin matches specific patterns (e.g., `https://assistify.*.vercel.app`, `https://assistify.*.fly.dev`, or `http://localhost:3000`), it allows credentials, various HTTP methods, and headers. The middleware handles OPTIONS preflight requests separately to set the necessary CORS headers.

```py
import re

from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware


# Custom CORS middleware to handle dynamic origins
class CustomCORSMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        origin = request.headers.get("origin")
        if origin and re.match(r"https://assistify.*\.(vercel\.app|fly\.dev)|http://localhost:3000", origin):
            if request.method == "OPTIONS":
                response = Response()
                response.headers["Access-Control-Allow-Origin"] = origin
                response.headers["Access-Control-Allow-Credentials"] = "true"
                response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
                response.headers["Access-Control-Allow-Headers"] = "authorization, content-type"
                return response
            response = await call_next(request)
            response.headers["Access-Control-Allow-Origin"] = origin
            response.headers["Access-Control-Allow-Credentials"] = "true"
            response.headers["Access-Control-Allow-Methods"] = "*"
            response.headers["Access-Control-Allow-Headers"] = "*"
            return response
        return await call_next(request)

```

## .env.default

### Summary

The code sets two environment variables with placeholders for their respective values - one for the OpenAI API key (`OPENAI_API_KEY`) and one for the Google Client ID (`GOOGLE_CLIENT_ID`). These variables are likely used for authenticating API requests to OpenAI and Google services.

```default
OPENAI_API_KEY=${OPENAI_API_KEY}

# Google Authentication
GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}

```
